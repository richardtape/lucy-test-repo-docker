# =============================================================================
# Nginx Load Balancer Configuration
# =============================================================================
#
# ARCHITECTURE OVERVIEW:
# ----------------------
# This load balancer sits in front of two web nodes and provides:
#   1. SSL termination (handles HTTPS from clients)
#   2. Cookie-based sticky sessions (session affinity)
#   3. Health checks for backend nodes
#   4. HTTPS proxying to backend web nodes
#
# TRAFFIC FLOW:
#   Client -> HTTPS (443) -> Nginx LB -> HTTPS (443) -> Web Node 1 or 2
#
# =============================================================================
# STICKY SESSIONS - HOW IT WORKS
# =============================================================================
#
# We implement sticky sessions using a cookie-based routing approach:
#
# FIRST REQUEST (no cookie):
#   1. Client connects to https://cms.test
#   2. Nginx has no SERVERID cookie to read
#   3. Nginx uses round-robin (or ip_hash) to select a backend
#   4. Backend (Apache) sets the SERVERID cookie with its node ID
#   5. Response includes: Set-Cookie: SERVERID=web-node-1 (or web-node-2)
#
# SUBSEQUENT REQUESTS (has cookie):
#   1. Client sends request with Cookie: SERVERID=web-node-1
#   2. Nginx reads the cookie using $cookie_SERVERID
#   3. Map directive translates cookie value to backend address
#   4. Request is routed to the correct backend
#   5. Session remains "sticky" to that node
#
# TESTING STICKY SESSIONS:
#   1. Open https://cms.test in Chrome - check X-Served-By header
#   2. Refresh several times - should stay on same node
#   3. Open https://cms.test in Firefox or Incognito - may get different node
#   4. That new session will be sticky to its assigned node
#   5. Use DevTools > Application > Cookies to see SERVERID cookie
#
# WHY NOT TRUE SSL PASSTHROUGH?
# -----------------------------
# True SSL passthrough (Layer 4 / stream module) cannot inspect HTTP headers
# or cookies since traffic is encrypted. To achieve cookie-based sticky
# sessions, we must terminate SSL at the load balancer. We then re-encrypt
# traffic to backends (SSL bridging) to maintain security.
#
# =============================================================================

# -----------------------------------------------------------------------------
# MAP: Translate SERVERID cookie value to backend server
# -----------------------------------------------------------------------------
# This map reads the SERVERID cookie and determines which backend to use.
# If the cookie doesn't exist or has an unknown value, $backend will be empty
# and we fall through to the default upstream load balancing.
# -----------------------------------------------------------------------------
map $cookie_SERVERID $backend {
    default         "";              # No cookie or unknown value - use upstream
    "web-node-1"    "web-node-1";    # Route to web-node-1
    "web-node-2"    "web-node-2";    # Route to web-node-2
}

# -----------------------------------------------------------------------------
# UPSTREAM: Pool of backend web servers
# -----------------------------------------------------------------------------
upstream web_backend {
    # Round-robin is used when no sticky cookie is present
    # ip_hash could be used as fallback but round-robin gives better distribution

    server web-node-1:443 max_fails=3 fail_timeout=30s;
    server web-node-2:443 max_fails=3 fail_timeout=30s;

    # Keepalive connections to backends for performance
    keepalive 32;
}

# Separate upstreams for direct routing when cookie is present
upstream backend_node1 {
    server web-node-1:443;
    keepalive 8;
}

upstream backend_node2 {
    server web-node-2:443;
    keepalive 8;
}

# -----------------------------------------------------------------------------
# HTTP Server: Redirect to HTTPS
# -----------------------------------------------------------------------------
server {
    listen 80;
    server_name cms.test;

    # Redirect all HTTP requests to HTTPS
    return 301 https://$host$request_uri;
}

# -----------------------------------------------------------------------------
# HTTPS Server: Main entry point with sticky session routing
# -----------------------------------------------------------------------------
server {
    listen 443 ssl;
    server_name cms.test;

    # SSL Configuration
    ssl_certificate /etc/nginx/certs/localhost.crt;
    ssl_certificate_key /etc/nginx/certs/localhost.key;

    # Modern SSL settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;

    # Logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # Health check endpoint (handled by Nginx itself, not proxied)
    location = /lb-health {
        access_log off;
        return 200 "load-balancer: healthy\n";
        add_header Content-Type text/plain;
    }

    # -------------------------------------------------------------------------
    # STICKY ROUTING LOGIC
    # -------------------------------------------------------------------------
    # We use conditional routing based on the SERVERID cookie value.
    # If cookie exists and matches a known node, route directly to that node.
    # If no cookie or unknown value, use the default upstream (round-robin).
    # -------------------------------------------------------------------------

    # Route to web-node-1 if cookie says so
    location @backend_node1 {
        proxy_pass https://backend_node1;
        include /etc/nginx/proxy_params.conf;
    }

    # Route to web-node-2 if cookie says so
    location @backend_node2 {
        proxy_pass https://backend_node2;
        include /etc/nginx/proxy_params.conf;
    }

    # Default routing (no cookie or unknown value)
    location @backend_default {
        proxy_pass https://web_backend;
        include /etc/nginx/proxy_params.conf;
    }

    # Main location - determine routing based on cookie
    location / {
        # Check the mapped backend value and route accordingly
        if ($backend = "web-node-1") {
            error_page 418 = @backend_node1;
            return 418;
        }
        if ($backend = "web-node-2") {
            error_page 418 = @backend_node2;
            return 418;
        }

        # No matching cookie - use default upstream
        error_page 418 = @backend_default;
        return 418;
    }
}
